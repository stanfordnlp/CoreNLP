/* SemgrexParser.java */
/* Generated By:JavaCC: Do not edit this line. SemgrexParser.java */
package edu.stanford.nlp.semgraph.semgrex;
// all generated classes are in this package

//imports
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.*;
import edu.stanford.nlp.util.Generics;
import edu.stanford.nlp.util.logging.Redwood;

class SemgrexParser implements SemgrexParserConstants {

  // this is so we can tell, at any point during the parse
  // whether we are under a negation, which we need to know
  // because labeling nodes under negation is illegal
  private boolean underNegation = false;
  private boolean underNodeNegation = false;
  // keep track of which variables we've already seen
  // lets us make sure we don't name new nodes under a negation
  private Set<String> knownVariables = Generics.newHashSet();

  private static final Redwood.RedwoodChannels log = Redwood.channels(SemgrexParser.class);
  private boolean deprecatedAmp = false;
  private boolean deprecatedNodeConj = false;

  private String fullExpression(Token startToken) {
    StringBuilder result = new StringBuilder();
    for (Token p = startToken; p != null; p = p.next) {
      if (p.specialToken != null) {
        result.append(p.specialToken.image);
      }
      result.append(p.image);
    }
    return result.toString();
  }

  private void warnDeprecated(String warning, Token startToken) {
    StringWriter sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    (new RuntimeException()).printStackTrace(pw);
    String trace = sw.toString();
    trace = trace.substring(trace.lastIndexOf("SemgrexParser"));
    trace = trace.substring(trace.indexOf("at "));
    log.warn(warning + "\n    " + fullExpression(startToken) + "\n    Current stack: " + trace);
  }

  final public SemgrexPattern Root() throws ParseException {// Root pattern for the semgrex parser.  Doesn't necessarily represent matching the root.
  SemgrexPattern node;
  Token reverse = null;
  List<SemgrexPattern> children = new ArrayList<SemgrexPattern>();
  Token startToken = null;

  List<String> uniqKeys = null;
  Token nextIdentifier = null;
  // a local variable

// start from 1 since we haven't parsed anything yet
    startToken = getToken(1);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ALIGNRELN:{
      reverse = jj_consume_token(ALIGNRELN);
      node = SubNode(GraphRelation.ALIGNED_ROOT);
      break;
      }
    case 13:
    case 17:
    case 19:
    case 29:{
      node = SubNode(GraphRelation.ROOT);
children.add(node);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 10:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(10);
        node = SubNode(GraphRelation.ITERATOR);
children.add(node);
      }
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (children.size() > 1)
        node = new CoordinationPattern(true, children, true, true);
      if (deprecatedAmp) {
        {if (true) throw new SemgrexParseException("Use of & in semgrex patterns is now illegal.  It is equivalent to the same expression without the &.  Offending expression: " + startToken);}
      }
      if (deprecatedNodeConj) {
        {if (true) throw new SemgrexParseException("Use of node conjugation (expressions such as '< [foo bar]' or '< [foo & bar]') is now illegal.  The issue is that expressions such as '[foo bar] < zzz' may intuitively mean that foo < zzz, bar < zzz, zzz the same for both cases, but that is not the way the parser interpreted this expression.  Changing the functionality might break existing expressions, and anyway this can be rewritten in various ways such as 'zzz > foo > bar' or 'foo < zzz=a : bar < zzz=a'.  Offending expression: " + startToken);}
      }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 11:{
      jj_consume_token(11);
      jj_consume_token(UNIQ);
uniqKeys = new ArrayList<>();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNIQ:
        case IDENTIFIER:{
          ;
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        nextIdentifier = identifier();
uniqKeys.add(nextIdentifier.image);
      }
for (String key : uniqKeys) {
          if (!knownVariables.contains(key)) {
            {if (true) throw new SemgrexParseException("Semgrex pattern asked for uniq of node " + key + " which does not exist in the pattern");}
          }
        }
        // TODO: can error check that the keys are unique between node and edge names
        // that might require keeping edge names in a known set
        // TODO: edge names might need some upgrades anyway - shouldn't name them under negation, for example
        node = new UniqPattern(node, uniqKeys);
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(12);
{if ("" != null) return node;}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern SubNode(GraphRelation r) throws ParseException {SemgrexPattern result =  null;
        SemgrexPattern child = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 13:{
      jj_consume_token(13);
      result = SubNode(r);
      jj_consume_token(14);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNIQ:
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 17:
      case 18:
      case 19:{
        child = RelationDisj();
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        ;
      }
if (child != null) {
                List<SemgrexPattern> newChildren = new ArrayList<SemgrexPattern>();
                newChildren.addAll(result.getChildren());
                newChildren.add(child);
                result.setChild(new CoordinationPattern(false, newChildren, true, false));
        }
        {if ("" != null) return result;}
      break;
      }
    case 17:
    case 19:
    case 29:{
      result = ModNode(r);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNIQ:
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 17:
      case 18:
      case 19:{
        child = RelationDisj();
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
if (child != null) result.setChild(child);
                {if ("" != null) return result;}
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern RelationDisj() throws ParseException {SemgrexPattern child;
        List<SemgrexPattern> children = new ArrayList<SemgrexPattern>();
    child = RelationConj();
children.add(child);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 15:{
        ;
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      jj_consume_token(15);
      child = RelationConj();
children.add(child);
    }
if (children.size() == 1) {
                {if ("" != null) return child;}
          } else {
                {if ("" != null) return new CoordinationPattern(false, children, false, false);}
      }
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern RelationConj() throws ParseException {SemgrexPattern child;
        List<SemgrexPattern> children = new ArrayList<SemgrexPattern>();
    child = ModRelation();
children.add(child);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNIQ:
      case RELATION:
      case ALIGNRELN:
      case IDENTIFIER:
      case 16:
      case 17:
      case 18:
      case 19:{
        ;
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 16:{
        jj_consume_token(16);
deprecatedAmp = true;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      child = ModRelation();
children.add(child);
    }
if (children.size() == 1) {
                {if ("" != null) return child;}
          } else {
                {if ("" != null) return new CoordinationPattern(false, children, true, false);}
      }
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern ModRelation() throws ParseException {SemgrexPattern child;
  boolean startUnderNeg;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQ:
    case RELATION:
    case ALIGNRELN:
    case IDENTIFIER:
    case 19:{
      child = RelChild();
      break;
      }
    case 17:{
      jj_consume_token(17);
startUnderNeg = underNegation;
          underNegation = true;
      child = RelChild();
underNegation = startUnderNeg;
child.negate();
      break;
      }
    case 18:{
      jj_consume_token(18);
      child = RelChild();
child.makeOptional();
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return child;}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern RelChild() throws ParseException {SemgrexPattern child;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 19:{
      jj_consume_token(19);
      child = RelationDisj();
      jj_consume_token(20);
      break;
      }
    case UNIQ:
    case RELATION:
    case ALIGNRELN:
    case IDENTIFIER:{
      child = Relation();
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return child;}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern Relation() throws ParseException {GraphRelation reln;
        Token rel = null;
        Token relnType = null;
        Token numArg = null;
        Token numArg2 = null;
        Token graphNumber = null;
        Token name = null;
        Token edgeName = null;
        SemgrexPattern node;
        boolean pC = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQ:
    case RELATION:
    case IDENTIFIER:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNIQ:
      case IDENTIFIER:{
        numArg = identifier();
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 21:{
          jj_consume_token(21);
          numArg2 = identifier();
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      rel = jj_consume_token(RELATION);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case UNIQ:
      case IDENTIFIER:
      case REGEX:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNIQ:
        case IDENTIFIER:{
          relnType = identifier();
          break;
          }
        case REGEX:{
          relnType = jj_consume_token(REGEX);
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 22:{
        jj_consume_token(22);
        graphNumber = jj_consume_token(NUMBER);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 23:{
        jj_consume_token(23);
        name = identifier();
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 24:{
        jj_consume_token(24);
        edgeName = identifier();
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      break;
      }
    case ALIGNRELN:{
      rel = jj_consume_token(ALIGNRELN);
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
if (numArg == null && numArg2 == null) {
            reln = GraphRelation.getRelation(rel != null ? rel.image : null,
                                             relnType != null ? relnType.image : null,
                                             name != null ? name.image : null,
                                             edgeName != null ? edgeName.image : null);
          } else if (numArg2 == null) {
            reln = GraphRelation.getRelation(rel != null ? rel.image : null,
                                             relnType != null ? relnType.image : null,
                                             Integer.parseInt(numArg.image),
                                             name != null ? name.image : null,
                                             edgeName != null ? edgeName.image : null);
          } else {
            reln = GraphRelation.getRelation(rel != null ? rel.image : null,
                                             relnType != null ? relnType.image : null,
                                             Integer.parseInt(numArg.image),
                                             Integer.parseInt(numArg2.image),
                                             name != null ? name.image : null,
                                             edgeName != null ? edgeName.image : null);
          }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 17:
    case 19:
    case 29:{
      node = ModNode(reln);
      break;
      }
    case 13:{
      jj_consume_token(13);
      node = SubNode(reln);
      jj_consume_token(14);
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return node;}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern NodeDisj(GraphRelation r) throws ParseException {SemgrexPattern child;
        List<SemgrexPattern> children = new ArrayList<SemgrexPattern>();
    jj_consume_token(19);
    child = NodeConj(r);
children.add(child);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 15:{
        ;
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        break label_5;
      }
      jj_consume_token(15);
      child = NodeConj(r);
children.add(child);
    }
    jj_consume_token(20);
if (children.size() == 1)
                {if ("" != null) return child;}
          else
                {if ("" != null) return new CoordinationPattern(true, children, false, false);}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern NodeConj(GraphRelation r) throws ParseException {SemgrexPattern child;
        List<SemgrexPattern> children = new ArrayList<SemgrexPattern>();
    child = ModNode(r);
children.add(child);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 16:
      case 17:
      case 19:
      case 29:{
        ;
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 16:{
        jj_consume_token(16);
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      child = ModNode(r);
children.add(child); deprecatedNodeConj = true;
    }
if (children.size() == 1)
                {if ("" != null) return child;}
          else
                {if ("" != null) return new CoordinationPattern(true, children, true, false);}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern ModNode(GraphRelation r) throws ParseException {SemgrexPattern child;
        boolean startUnderNeg;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 19:
    case 29:{
      child = Child(r);
      break;
      }
    case 17:{
      jj_consume_token(17);
startUnderNeg = underNodeNegation; // TODO: can negations be nested?  If so, should they cancel?
                    underNodeNegation = true;
      child = Child(r);
underNodeNegation = startUnderNeg;
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return child;}
    throw new Error("Missing return statement in function");
}

  final public SemgrexPattern Child(GraphRelation r) throws ParseException {SemgrexPattern child;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 19:{
      child = NodeDisj(r);
      break;
      }
    case 29:{
      child = Description(r);
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return child;}
    throw new Error("Missing return statement in function");
}

  final public void AddAttribute(NodeAttributes attributes) throws ParseException {Token attr = null;
        Token key = null;
        Token value = null;
        Token attrType = null;
        boolean negated = false;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQ:
    case IDENTIFIER:{
      attr = identifier();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 10:
      case 25:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 10:{
          attrType = jj_consume_token(10);
          break;
          }
        case 25:{
          attrType = jj_consume_token(25);
          break;
          }
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNIQ:
        case IDENTIFIER:{
          value = identifier();
          break;
          }
        case REGEX:{
          value = jj_consume_token(REGEX);
          break;
          }
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
if (attr != null && value != null) {
               negated = attrType.image.equals("!:");
               attributes.setAttribute(attr.image, value.image, negated);
             }
        break;
        }
      case 26:{
        jj_consume_token(26);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNIQ:
        case IDENTIFIER:{
          key = identifier();
          break;
          }
        case REGEX:{
          key = jj_consume_token(REGEX);
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 10:{
          attrType = jj_consume_token(10);
          break;
          }
        case 25:{
          attrType = jj_consume_token(25);
          break;
          }
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case UNIQ:
        case IDENTIFIER:{
          value = identifier();
          break;
          }
        case REGEX:{
          value = jj_consume_token(REGEX);
          break;
          }
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
if (attr == null || key == null || value == null) {
               {if (true) throw new SemgrexParseException("null while parsing semgrex expression: attr=" + attr +
                                               " key=" + key + " value=" + value);}
             }
             negated = attrType.image.equals("!:");
             attributes.addContains(attr.image, key.image, value.image, negated);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 27:{
            ;
            break;
            }
          default:
            jj_la1[31] = jj_gen;
            break label_7;
          }
          jj_consume_token(27);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNIQ:
          case IDENTIFIER:{
            key = identifier();
            break;
            }
          case REGEX:{
            key = jj_consume_token(REGEX);
            break;
            }
          default:
            jj_la1[32] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 10:{
            attrType = jj_consume_token(10);
            break;
            }
          case 25:{
            attrType = jj_consume_token(25);
            break;
            }
          default:
            jj_la1[33] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case UNIQ:
          case IDENTIFIER:{
            value = identifier();
            break;
            }
          case REGEX:{
            value = jj_consume_token(REGEX);
            break;
            }
          default:
            jj_la1[34] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
if (attr == null || key == null || value == null) {
               {if (true) throw new SemgrexParseException("null while parsing semgrex expression: attr=" + attr +
                                               " key=" + key + " value=" + value);}
             }
             negated = attrType.image.equals("!:");
             attributes.addContains(attr.image, key.image, value.image, negated);
        }
        jj_consume_token(28);
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    case ROOT:{
      attr = jj_consume_token(ROOT);
attributes.setRoot(true);
      break;
      }
    case EMPTY:{
      attr = jj_consume_token(EMPTY);
attributes.setEmpty(true);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
}

  final public NodePattern Description(GraphRelation r) throws ParseException {Token name = null;
        boolean link = false;
        NodeAttributes attributes = new NodeAttributes();
        NodePattern pat;
    jj_consume_token(29);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQ:
    case IDENTIFIER:
    case EMPTY:
    case ROOT:{
      AddAttribute(attributes);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 27:{
          ;
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          break label_8;
        }
        jj_consume_token(27);
        AddAttribute(attributes);
      }
      break;
      }
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    jj_consume_token(28);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 24:{
      jj_consume_token(24);
link = true;
      name = identifier();
String nodeName = name.image;
              if (underNegation) {
                if (!knownVariables.contains(nodeName)) {
                  {if (true) throw new ParseException("Cannot add new variable names under negation.  Node '" + nodeName + "' not seen before");}
                }
              } else {
                knownVariables.add(nodeName);
              }
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      ;
    }
pat = new NodePattern(r, underNodeNegation, attributes, link, name != null ? name.image : null);
          {if ("" != null) return pat;}
    throw new Error("Missing return statement in function");
}

  final public Token identifier() throws ParseException {Token t ;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQ:{
      t = jj_consume_token(UNIQ);
      break;
      }
    case IDENTIFIER:{
      t = jj_consume_token(IDENTIFIER);
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
}

  /** Generated Token Manager. */
  public SemgrexParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[41];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {0x400,0x200a2010,0x24,0x800,0xe003c,0xe003c,0x200a2000,0x8000,0xf003c,0x10000,0xe003c,0x8003c,0x200000,0x24,0x224,0x224,0x400000,0x800000,0x1000000,0x3c,0x200a2000,0x8000,0x200b0000,0x10000,0x200a0000,0x20080000,0x2000400,0x224,0x224,0x2000400,0x224,0x8000000,0x224,0x2000400,0x224,0x6000400,0x1a4,0x8000000,0x1a4,0x1000000,0x24,};
	}

  /** Constructor with InputStream. */
  public SemgrexParser(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SemgrexParser(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new SemgrexParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SemgrexParser(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new SemgrexParserTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new SemgrexParserTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SemgrexParser(SemgrexParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SemgrexParserTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 41; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[30];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 41; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 30; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
