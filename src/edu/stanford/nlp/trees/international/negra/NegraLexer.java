/* The following code was generated by JFlex 1.3.5 on 5/2/03 5:39 PM */

package edu.stanford.nlp.trees.international.negra;

import edu.stanford.nlp.io.Lexer;

import java.io.IOException;

/** A lexer for the NEGRA corpus export format.  Inherits ACCEPT and
 * IGNORE fields from
 * edu.stanford.nlp.io<code>Lexer</code>.
 *
 * @author Roger Levy
 */


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 5/2/03 5:39 PM from the specification file
 * <tt>file:/dfs/hake/0/rog/javanlp/src/edu/stanford/nlp/trees/international/negra/negra.flex</tt>
 */
class NegraLexer implements Lexer {

  /**
   * This character denotes the end of file
   */
  final public static int YYEOF = -1;

  /**
   * initial size of the lookahead buffer
   */
  final private static int YY_BUFFERSIZE = 16384;

  /**
   * lexical states
   */
  final public static int SENTENCE = 1;
  final public static int YYINITIAL = 0;

  /**
   * Translates characters to character classes
   */
  final private static String yycmap_packed = "\12\0\1\2\1\3\1\3\1\1\22\0\1\7\17\0\12\7\10\0" + "\1\4\2\0\1\10\11\0\1\5\3\0\1\6\61\0\1\3\u1fa2\0" + "\1\3\1\3\udfd6\0";

  /**
   * Translates characters to character classes
   */
  final private static char[] yycmap = yy_unpack_cmap(yycmap_packed);

  /**
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = {0, 9, 18, 27, 36, 45, 27, 54, 63, 72, 81, 90, 99, 108, 117, 126, 135, 144};

  /**
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 = "\2\3\1\4\6\3\1\5\1\6\1\7\1\10\5\5" + "\4\0\1\11\15\0\1\12\3\0\4\12\1\13\2\0" + "\1\7\5\0\1\14\10\0\1\14\5\0\1\15\3\0" + "\1\12\3\0\6\12\3\0\1\12\1\16\3\12\5\0" + "\1\17\11\0\1\20\2\0\1\12\3\0\2\12\1\21" + "\2\12\6\0\1\22\11\0\1\20\1\0\1\12\3\0" + "\3\12\1\21\1\12\7\0\1\22\1\0";

  /**
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {"Unkown internal scanner error", "Internal error: unknown state", "Error: could not match input", "Error: pushback value was too large"};

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {0, 0, 1, 9, 1, 1, 9, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1};

  /**
   * the input device
   */
  private java.io.Reader yy_reader;

  /**
   * the current state of the DFA
   */
  private int yy_state;

  /**
   * the current lexical state
   */
  private int yy_lexical_state = YYINITIAL;

  /**
   * this buffer contains the current text to be matched and is
   * the source of the yytext() string
   */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /**
   * the textposition at the last accepting state
   */
  private int yy_markedPos;

  /**
   * the textposition at the last state to be included in yytext
   */
  private int yy_pushbackPos;

  /**
   * the current text position in the buffer
   */
  private int yy_currentPos;

  /**
   * startRead marks the beginning of the yytext() string in the buffer
   */
  private int yy_startRead;

  /**
   * endRead marks the last character in the buffer, that has been read
   * from input
   */
  private int yy_endRead;

  /**
   * number of newlines encountered up to the start of the matched text
   */
  private int yyline;

  /**
   * the number of characters up to the start of the matched text
   */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private int yycolumn;

  /**
   * yy_atBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /**
   * yy_atEOF == true <=> the scanner is at the EOF
   */
  private boolean yy_atEOF;

  /* user code: */
  public void pushBack(int n) {
    yypushback(n);
  }

  public int getYYEOF() {
    return YYEOF;
  }


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param in the java.io.Reader to read input from.
   */
  NegraLexer(java.io.Reader in) {
    this.yy_reader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param in the java.io.Inputstream to read input from.
   */
  NegraLexer(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /**
   * Unpacks the split, compressed DFA transition table.
   *
   * @return the unpacked transition table
   */
  private static int[] yy_unpack() {
    int[] trans = new int[153];
    int offset = 0;
    offset = yy_unpack(yy_packed0, offset, trans);
    return trans;
  }

  /**
   * Unpacks the compressed DFA transition table.
   *
   * @param packed the packed transition table
   * @return the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int[] trans) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do {
        trans[j++] = value;
      } while (--count > 0);
    }
    return j;
  }

  /**
   * Unpacks the compressed character translation table.
   *
   * @param packed the packed character translation table
   * @return the unpacked character translation table
   */
  private static char[] yy_unpack_cmap(String packed) {
    char[] map = new char[0x10000];
    int i = 0;  /* index in packed string  */
    int j = 0;  /* index in unpacked array */
    while (i < 46) {
      int count = packed.charAt(i++);
      char value = packed.charAt(i++);
      do {
        map[j++] = value;
      } while (--count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return <code>false</code>, iff there was new input.
   * @throws IOException if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (yy_startRead > 0) {
      System.arraycopy(yy_buffer, yy_startRead, yy_buffer, 0, yy_endRead - yy_startRead);

      /* translate stored positions */
      yy_endRead -= yy_startRead;
      yy_currentPos -= yy_startRead;
      yy_markedPos -= yy_startRead;
      yy_pushbackPos -= yy_startRead;
      yy_startRead = 0;
    }

    /* is the buffer big enough? */
    if (yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[yy_currentPos * 2];
      System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
      yy_buffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = yy_reader.read(yy_buffer, yy_endRead, yy_buffer.length - yy_endRead);

    if (numRead < 0) {
      return true;
    } else {
      yy_endRead += numRead;
      return false;
    }
  }


  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
    yy_atEOF = true;            /* indicate end of file */
    yy_endRead = yy_startRead;  /* invalidate buffer    */

    if (yy_reader != null) {
      yy_reader.close();
    }
  }


  /**
   * Closes the current stream, and resets the
   * scanner to read from a new input stream.
   * <p/>
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>YY_INITIAL</tt>.
   *
   * @param reader the new input stream
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
    yyclose();
    yy_reader = reader;
    yy_atBOL = true;
    yy_atEOF = false;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yychar = yycolumn = 0;
    yy_lexical_state = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
    return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  final public void yybegin(int newState) {
    yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
    return new String(yy_buffer, yy_startRead, yy_markedPos - yy_startRead);
  }


  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   * <p/>
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
    return yy_buffer[yy_startRead + pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
    return yy_markedPos - yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   * <p/>
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   * <p/>
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param errorCode the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
    String message;
    try {
      message = YY_ERROR_MSG[errorCode];
    } catch (ArrayIndexOutOfBoundsException e) {
      message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
    }

    throw new Error(message);
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   * <p/>
   * They will be read again by then next call of the scanning method
   *
   * @param number the number of characters to be read again.
   *               This number must not be greater than yylength()!
   */
  private void yypushback(int number) {
    if (number > yylength()) {
      yy_ScanError(YY_PUSHBACK_2BIG);
    }

    yy_markedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return the next token
   * @throws IOException if any I/O-Error occurs
   */
  public int yylex() throws java.io.IOException {
    int yy_input;
    int yy_action;

    // cached fields:
    int yy_currentPos_l;
    int yy_startRead_l;
    int yy_markedPos_l;
    int yy_endRead_l = yy_endRead;
    char[] yy_buffer_l = yy_buffer;
    char[] yycmap_l = yycmap;

    int[] yytrans_l = yytrans;
    int[] yy_rowMap_l = yy_rowMap;
    byte[] yy_attr_l = YY_ATTRIBUTE;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l;

      yy_state = yy_lexical_state;


      yy_forAction: {
        while (true) {

          if (yy_currentPos_l < yy_endRead_l) {
            yy_input = yy_buffer_l[yy_currentPos_l++];
          } else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          } else {
            // store back cached positions
            yy_currentPos = yy_currentPos_l;
            yy_markedPos = yy_markedPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l = yy_currentPos;
            yy_markedPos_l = yy_markedPos;
            yy_buffer_l = yy_buffer;
            yy_endRead_l = yy_endRead;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            } else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
          int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
          if (yy_next == -1) {
            break yy_forAction;
          }
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ((yy_attributes & 1) == 1) {
            yy_action = yy_state;
            yy_markedPos_l = yy_currentPos_l;
            if ((yy_attributes & 8) == 8) {
              break yy_forAction;
            }
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      switch (yy_action) {

        case 4:
        case 9:
        case 10:
        case 13:
          {
            return ACCEPT;
          }
        case 19:
          break;
        case 5:
        case 6:
        case 7:
          {
            return IGNORE;
          }
        case 20:
          break;
        case 2:
          {
            return IGNORE;
          }
        case 21:
          break;
        case 15:
          {
            yybegin(SENTENCE);
            /* System.out.println("Beginning of sentence"); */
            return ACCEPT;
          }
        case 22:
          break;
        case 3:
          {
            System.out.print(yytext());
          }
        case 23:
          break;
        case 16:
        case 17:
          {
            yybegin(YYINITIAL);
            /* System.out.println("End of sentence"); */
            return ACCEPT;
          }
        case 24:
          break;
        default:
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            return YYEOF;
          } else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }

  /**
   * Runs the scanner on input files.
   * <p/>
   * This is a standalone scanner, i.e. it will print any unmatched
   * text to System.out unchanged.
   *
   * @param argv the command line, contains the filenames to run
   *             the scanner on.
   */
  public static void main(String argv[]) {
    if (argv.length == 0) {
      System.out.println("Usage : java NegraLexer <inputfile>");
    } else {
      for (int i = 0; i < argv.length; i++) {
        NegraLexer scanner = null;
        try {
          scanner = new NegraLexer(new java.io.FileReader(argv[i]));
          while (!scanner.yy_atEOF) {
            scanner.yylex();
          }
        } catch (java.io.FileNotFoundException e) {
          System.out.println("File not found : \"" + argv[i] + "\"");
        } catch (java.io.IOException e) {
          System.out.println("IO error scanning file \"" + argv[i] + "\"");
          System.out.println(e);
        } catch (Exception e) {
          System.out.println("Unexpected exception:");
          e.printStackTrace();
        }
      }
    }
  }


}
