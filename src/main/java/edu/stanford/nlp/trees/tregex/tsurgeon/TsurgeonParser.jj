/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. TsurgeonParser.jj */
/*@egen*/// java jjtree "-OUTPUT_DIRECTORY=projects/core/src/edu/stanford/nlp/trees/tregex/tsurgeon" projects/core/src/edu/stanford/nlp/trees/tregex/tsurgeon/TsurgeonParser.jjt
// java javacc "-OUTPUT_DIRECTORY=projects/core/src/edu/stanford/nlp/trees/tregex/tsurgeon" projects/core/src/edu/stanford/nlp/trees/tregex/tsurgeon/TsurgeonParser.jj

options { UNICODE_INPUT = true;
          SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
          STATIC = false; }

PARSER_BEGIN(TsurgeonParser)

package edu.stanford.nlp.trees.tregex.tsurgeon;

import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.util.Generics;
import java.util.*;


class TsurgeonParser/*@bgen(jjtree)*/implements TsurgeonParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTTsurgeonParserState jjtree = new JJTTsurgeonParserState();

/*@egen*/

  private TreeFactory treeFactory = new LabeledScoredTreeFactory();

  public static void main(String[] args) {
    System.out.println("Reading from standard input...");
    TsurgeonParser t = new TsurgeonParser(System.in);
    try {
      TsurgeonPattern n = t.Root();
      System.out.println(n.toString());
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

}

PARSER_END(TsurgeonParser)


<*> SKIP:
{
  " "
| "\r"
| "\t"
| "\n"
}

<*> TOKEN:
{
  < OPEN_BRACKET: "[" > : DEFAULT
}

TOKEN:
{ < IF: "if" >
| < NOT: "not" >
| < EXISTS: "exists" > : CONDITIONAL
| < DELETE: "delete" > : OPERATION
| < PRUNE:  "prune" > : OPERATION
| < RELABEL: "relabel" > : OPERATION
| < EXCISE: "excise" > : OPERATION
| < INSERT: "insert" > : OPERATION
| < MOVE: "move" > : OPERATION
| < REPLACE: "replace" >  : OPERATION
| < CREATE_SUBTREE: "createSubtree" > : OPERATION
| < ADJOIN: "adjoin" > : OPERATION
| < ADJOIN_TO_HEAD: "adjoinH" > : OPERATION
| < ADJOIN_TO_FOOT: "adjoinF" > : OPERATION
| < COINDEX: "coindex" > : OPERATION
}

<CONDITIONAL> TOKEN:
{ < NAME: ( ~[" ","\n","\r","[","]","(",")",":"] )+ > : DEFAULT }

<OPERATION> TOKEN:
{
  < CLOSE_BRACKET: "]" >
| < SELECTION: "#rightmost" | "#leftmost" >
| < GENERAL_RELABEL: "/" ("\\/"|~["\n","\r"])* "/" ( ("=" (["0"-"9","_","a"-"z","A"-"Z"])+) | ("%" (["0"-"9","_","a"-"z","A"-"Z"])+) | ("/" ("\\/"|"\\]"|"\\\\"|~["\n","\r","]","\\"])* "/") )+ >
| < IDENTIFIER: ~[" ","0"-"9","\n","\r","(","/","|","@","!","#","%","&",")","=","?","[","]",">","<","~","_",".",",","$",":","{","}",";"] ( ~[" ","\n","\r","(","/","@","!","#","%","&",")","=","?","[","]",">","<","~",".",",","$",":"] )* >
| < LOCATION_RELATION: "$-" | "$+" | ">" ("-")? (["0"-"9"])+ >
| < REGEX: "/" ("\\/"|"\\]"|"\\\\"|~["\n","\r","]","\\"])* "/" >
| < QUOTEX: "|" ("\\|"|"\\\\"|~["\n","\r","|","\\"])* "|" >
| < HASH_INTEGER: "#" (["0"-"9"])+ >
| < TREE_NODE_TERMINAL_LABEL: ( ~[" ","\n","\r","[","]","(",")",":"] )+ >
| < TREE_NODE_NONTERMINAL_LABEL: "(" ( ["-","a"-"z","A"-"Z","_","0"-"9","|","@","=","!","#","$","%","^","&","*","'","`","~",">","<","?",",",".","/","{","}","[","]","+","\\"] )* >
| < CLOSE_PAREN: ")" >
}

// TODO: this is wasteful in terms of creating TsurgeonPatternRoot.
// Should separate that out into another production
TsurgeonPatternRoot Root() :
{/*@bgen(jjtree) Root */
  SimpleNode jjtn000 = new SimpleNode(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token name;
  TsurgeonPattern result;
  List<TsurgeonPattern> results = null;
}
{/*@bgen(jjtree) Root */
  try {
/*@egen*/
  result = Operation()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return new TsurgeonPatternRoot(result); }
 | LOOKAHEAD(2)
  ( <IF> <EXISTS> name = <NAME> result = Root() )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return new TsurgeonPatternRoot(new IfExistsNode(name.image, false, result.children)); }
 | LOOKAHEAD(2)
  ( <IF> <NOT> <EXISTS> name = <NAME> result = Root() )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return new TsurgeonPatternRoot(new IfExistsNode(name.image, true, result.children)); }
 |
  ( <OPEN_BRACKET> result = Root() <CLOSE_BRACKET>
    {
      if (results == null) {
        results = Generics.newArrayList();
      }
      for (TsurgeonPattern child : result.children) {
        results.add(child);
      }
    } )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    TsurgeonPattern[] array = new TsurgeonPattern[results.size()];
    return new TsurgeonPatternRoot(results.toArray(array));
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

TsurgeonPattern Operation() :
{/*@bgen(jjtree) Operation */
  SimpleNode jjtn000 = new SimpleNode(JJTOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  TsurgeonPattern child1;
  TsurgeonPattern child2 = null;
  Token newLabel = null;
  TreeLocation loc = null;
  Token operator;
  AuxiliaryTree tree = null;
  List<AuxiliaryTree> treeList = null;
  List<TsurgeonPattern> nodeSelections = null;
  Token regex;
  Token hash_int;
}
{/*@bgen(jjtree) Operation */
  try {
/*@egen*/
  operator = <DELETE> nodeSelections = NodeSelectionList(new ArrayList<TsurgeonPattern>())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new DeleteNode(nodeSelections); }
| operator = <PRUNE> nodeSelections = NodeSelectionList(new ArrayList<TsurgeonPattern>())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new PruneNode(nodeSelections); }
| operator = <EXCISE> child1 = NodeSelection() child2 = NodeSelection()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new ExciseNode(child1,child2); }
| LOOKAHEAD(3)
  operator = <RELABEL> child1 = NodeSelection() newLabel = <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new RelabelNode(child1,newLabel.image); }
| LOOKAHEAD(3)
  operator = <RELABEL> child1 = NodeSelection() newLabel = <QUOTEX>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new RelabelNode(child1, newLabel.image); }
| LOOKAHEAD(3)
  operator = <RELABEL> child1 = NodeSelection() regex = <REGEX>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new RelabelNode(child1, regex.image); }
| LOOKAHEAD(3)
  operator = <RELABEL> child1 = NodeSelection() newLabel = <GENERAL_RELABEL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new RelabelNode(child1, newLabel.image); }
| LOOKAHEAD(3)
  operator = <REPLACE> child1 = NodeSelection() child2 = NodeSelection()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new ReplaceNode(child1,child2); }
| LOOKAHEAD(3)
  operator = <REPLACE> child1 = NodeSelection() treeList = TreeList(false)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new ReplaceNode(child1,treeList); }
|  operator = <MOVE> child1 = NodeSelection() loc = Location()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new MoveNode(child1, loc); }
| LOOKAHEAD(3)
  operator = <INSERT> child1 = NodeSelection() loc = Location()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new InsertNode(child1, loc); }
| LOOKAHEAD(3)
  operator = <INSERT> tree = TreeRoot(false) loc = Location()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new InsertNode(tree, loc); }
| operator = <CREATE_SUBTREE> tree = TreeRoot(false) nodeSelections = NodeSelectionList(new ArrayList<TsurgeonPattern>())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { if (nodeSelections.size() == 1) {
        return new CreateSubtreeNode(nodeSelections.get(0), tree);
      } else if (nodeSelections.size() == 2) {
        return new CreateSubtreeNode(nodeSelections.get(0), nodeSelections.get(1), tree);
      } else {
        throw new ParseException("Illegal number of nodes given to createSubtree (" + nodeSelections.size() + ")");
      }
    }
| operator = <ADJOIN> tree = TreeRoot(true) child1 = NodeSelection()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new AdjoinNode(tree, child1); }
| operator = <ADJOIN_TO_HEAD> tree = TreeRoot(true) child1 = NodeSelection()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new AdjoinToHeadNode(tree, child1); }
| operator = <ADJOIN_TO_FOOT> tree = TreeRoot(true) child1 = NodeSelection()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new AdjoinToFootNode(tree, child1); }
| operator = <COINDEX> nodeSelections = NodeSelectionList(new ArrayList<TsurgeonPattern>())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new CoindexNodes(nodeSelections.toArray(new TsurgeonPattern[] {})); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

TreeLocation Location() :
{/*@bgen(jjtree) Location */
  SimpleNode jjtn000 = new SimpleNode(JJTLOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token rel;
  TsurgeonPattern child;
}
{/*@bgen(jjtree) Location */
 try {
/*@egen*/
 rel = <LOCATION_RELATION> child = NodeSelection()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return new TreeLocation(rel.image, child); }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}


List<TsurgeonPattern> NodeSelectionList(List<TsurgeonPattern> l) :
{/*@bgen(jjtree) NodeSelectionList */
  SimpleNode jjtn000 = new SimpleNode(JJTNODESELECTIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  TsurgeonPattern result;
}
{/*@bgen(jjtree) NodeSelectionList */
 try {
/*@egen*/
 ( ( result = NodeSelection() ) { l.add(result); }
 ( ( result = NodeSelection() ) {l.add(result); } )* )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return l; }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// TODO: what does this next comment mean?
// we'll also put in a way to use a SELECTION with a list of nodes.
TsurgeonPattern NodeSelection() :
{/*@bgen(jjtree) NodeSelection */
  SimpleNode jjtn000 = new SimpleNode(JJTNODESELECTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  TsurgeonPattern result;
}
{/*@bgen(jjtree) NodeSelection */
  try {
/*@egen*/
  result =  NodeName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return result; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

TsurgeonPattern NodeName() :
{/*@bgen(jjtree) NodeName */
  SimpleNode jjtn000 = new SimpleNode(JJTNODENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) NodeName */
  try {
/*@egen*/
  t=<IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return new FetchNode(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

List<AuxiliaryTree> TreeList(boolean requiresFoot) :
{/*@bgen(jjtree) TreeList */
  SimpleNode jjtn000 = new SimpleNode(JJTTREELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  List<AuxiliaryTree> trees = Generics.newArrayList();
  AuxiliaryTree tree;
}
{/*@bgen(jjtree) TreeList */
 try {
/*@egen*/
 ( ( tree = TreeRoot(requiresFoot) ) { trees.add(tree); }
 ( ( tree = TreeRoot(requiresFoot) ) { trees.add(tree); } )* )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return trees; }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}


// the argument says whether there must be a foot node on the aux tree.
AuxiliaryTree TreeRoot(boolean requiresFoot) :
{/*@bgen(jjtree) TreeRoot */
  SimpleNode jjtn000 = new SimpleNode(JJTTREEROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Tree t;
}
{/*@bgen(jjtree) TreeRoot */
  try {
/*@egen*/
  t = TreeNode()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return new AuxiliaryTree(t,requiresFoot); }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Tree TreeNode() :
{/*@bgen(jjtree) TreeNode */
 SimpleNode jjtn000 = new SimpleNode(JJTTREENODE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token label;
 List<Tree> dtrs = null;
}
{/*@bgen(jjtree) TreeNode */
 try {
/*@egen*/
 label = <TREE_NODE_NONTERMINAL_LABEL> dtrs = TreeDtrs(new ArrayList<Tree>())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return treeFactory.newTreeNode(label.image.substring(1),dtrs); }
| ( label = <TREE_NODE_TERMINAL_LABEL> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return treeFactory.newTreeNode(label.image,new ArrayList<Tree>()); }
| ( label = <IDENTIFIER> )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return treeFactory.newTreeNode(label.image,new ArrayList<Tree>()); }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

List<Tree> TreeDtrs(List<Tree> dtrs) :
{/*@bgen(jjtree) TreeDtrs */
  SimpleNode jjtn000 = new SimpleNode(JJTTREEDTRS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Tree tree;
}
{/*@bgen(jjtree) TreeDtrs */
  try {
/*@egen*/
  tree = TreeNode() TreeDtrs(dtrs)/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {dtrs.add(0,tree); return dtrs; }
| <CLOSE_PAREN>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return dtrs; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}